<!-- build time:Tue Apr 28 2020 11:58:04 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Python,"><link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml"><meta name="description" content="面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP01. 面向对象基本概念我们之前学习的编程方式就是 面向过程 的面相过程 和 面相对象，是两种不同的 编程方式对比 面向过程 的特点，可以更好地了解什么是 面向对象1.1 过程和函数（科普）过程 是早期的一个编程概念过程 类似于函数，只能执行，但是没有返回值函数 不仅能执行，还可以返回"><meta name="keywords" content="Python"><meta property="og:type" content="article"><meta property="og:title" content="python_面向对象"><meta property="og:url" content="https://yongnights.github.io/2019/12/31/python_面向对象/index.html"><meta property="og:site_name" content="个人博客"><meta property="og:description" content="面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP01. 面向对象基本概念我们之前学习的编程方式就是 面向过程 的面相过程 和 面相对象，是两种不同的 编程方式对比 面向过程 的特点，可以更好地了解什么是 面向对象1.1 过程和函数（科普）过程 是早期的一个编程概念过程 类似于函数，只能执行，但是没有返回值函数 不仅能执行，还可以返回"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-12-31T04:00:48.270Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python_面向对象"><meta name="twitter:description" content="面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP01. 面向对象基本概念我们之前学习的编程方式就是 面向过程 的面相过程 和 面相对象，是两种不同的 编程方式对比 面向过程 的特点，可以更好地了解什么是 面向对象1.1 过程和函数（科普）过程 是早期的一个编程概念过程 类似于函数，只能执行，但是没有返回值函数 不仅能执行，还可以返回"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://yongnights.github.io/2019/12/31/python_面向对象/"><title>python_面向对象 | 个人博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">个人博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">记录工作中的点点滴滴</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yongnights.github.io/2019/12/31/python_面向对象/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="永夜初晗凝碧天"><meta itemprop="description" content><meta itemprop="image" content="/img/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">python_面向对象</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-31T12:00:48+08:00">2019-12-31 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-12-31T12:00:48+08:00">2019-12-31 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i>本文总阅读量 <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次</span><div class="post-wordcount"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">10.1k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">37 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面向对象-OOP-基本概念"><a href="#面向对象-OOP-基本概念" class="headerlink" title="面向对象(OOP)基本概念"></a>面向对象(OOP)基本概念</h1><p>面向对象编程 —— Object Oriented Programming 简写 OOP</p><h2 id="01-面向对象基本概念"><a href="#01-面向对象基本概念" class="headerlink" title="01. 面向对象基本概念"></a>01. 面向对象基本概念</h2><ul><li>我们之前学习的编程方式就是 面向过程 的</li><li>面相过程 和 面相对象，是两种不同的 编程方式</li><li>对比 面向过程 的特点，可以更好地了解什么是 面向对象</li></ul><h3 id="1-1-过程和函数（科普）"><a href="#1-1-过程和函数（科普）" class="headerlink" title="1.1 过程和函数（科普）"></a>1.1 过程和函数（科普）</h3><ul><li>过程 是早期的一个编程概念</li><li>过程 类似于函数，只能执行，但是没有返回值</li><li>函数 不仅能执行，还可以返回结果</li></ul><a id="more"></a><h3 id="1-2-面相过程-和-面相对象-基本概念"><a href="#1-2-面相过程-和-面相对象-基本概念" class="headerlink" title="1.2 面相过程 和 面相对象 基本概念"></a>1.2 面相过程 和 面相对象 基本概念</h3><p>1) 面相过程 —— 怎么做？</p><pre><code>1. 把完成某一个需求的 所有步骤 从头到尾 逐步实现
2. 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数
3. 最后完成的代码，就是顺序地调用 不同的函数
</code></pre><p>特点</p><pre><code>1. 注重 步骤与过程，不注重职责分工
2. 如果需求复杂，代码会变得很复杂
3. 开发复杂项目，没有固定的套路，开发难度很大！
</code></pre><p>2) 面向对象 —— 谁来做？</p><blockquote><p>相比较函数，面向对象 是 更大 的 封装，根据 职责 在 一个对象中 封装 多个方法</p></blockquote><ol><li>在完成某一个需求前，首先确定 职责 —— 要做的事情（方法）</li><li>根据 职责 确定不同的 对象，在 对象 内部封装不同的 方法（多个）</li><li>最后完成的代码，就是顺序地让 不同的对象 调用 不同的方法</li></ol><p>特点</p><pre><code>1. 注重 对象和职责，不同的对象承担不同的职责
2. 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路
3. 需要在面向过程基础上，再学习一些面向对象的语法
</code></pre><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="01-类和对象的概念"><a href="#01-类和对象的概念" class="headerlink" title="01. 类和对象的概念"></a>01. 类和对象的概念</h2><p>类 和 对象 是 面向对象编程的 两个 核心概念</p><h3 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1 类"></a>1.1 类</h3><ul><li>类 是对一群具有 相同 特征 或者 行为 的事物的一个统称，是抽象的，不能直接使用<ul><li>特征 被称为 属性</li><li>行为 被称为 方法</li></ul></li><li>类 就相当于制造飞机时的图纸，是一个 模板，是 负责创建对象的</li></ul><p>1.2 对象</p><ul><li>对象 是 由类创建出来的一个具体存在，可以直接使用</li><li>由 哪一个类 创建出来的 对象，就拥有在 哪一个类 中定义的：<ul><li>属性</li><li>方法</li></ul></li><li>对象 就相当于用 图纸 制造 的飞机<blockquote><p>在程序开发中，应该 先有类，再有对象</p></blockquote></li></ul><h2 id="02-类和对象的关系"><a href="#02-类和对象的关系" class="headerlink" title="02. 类和对象的关系"></a>02. 类和对象的关系</h2><ul><li>类是模板，对象 是根据 类 这个模板创建出来的，应该 先有类，再有对象</li><li>类 只有一个，而 对象 可以有很多个<ul><li>不同的对象 之间 属性 可能会各不相同</li></ul></li><li>类 中定义了什么 属性和方法，对象 中就有什么属性和方法，不可能多，也不可能少</li></ul><h2 id="03-类的设计"><a href="#03-类的设计" class="headerlink" title="03. 类的设计"></a>03. 类的设计</h2><p>在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！<br>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p><pre><code>1. 类名 这类事物的名字，满足大驼峰命名法
2. 属性 这类事物具有什么样的特征
3. 方法 这类事物具有什么样的行为
</code></pre><blockquote><p>大驼峰命名法</p><ol><li>每一个单词的首字母大写</li><li>单词与单词之间没有下划线</li></ol></blockquote><h3 id="3-1-类名的确定"><a href="#3-1-类名的确定" class="headerlink" title="3.1 类名的确定"></a>3.1 类名的确定</h3><p>名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类</p><p>3.2 属性和方法的确定</p><ul><li>对 对象的特征描述，通常可以定义成 属性</li><li>对象具有的行为（动词），通常可以定义成 方法<blockquote><p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑</p></blockquote></li></ul><h1 id="面相对象基础语法"><a href="#面相对象基础语法" class="headerlink" title="面相对象基础语法"></a>面相对象基础语法</h1><h2 id="01-dir-内置函数（知道）"><a href="#01-dir-内置函数（知道）" class="headerlink" title="01. dir 内置函数（知道）"></a>01. dir 内置函数（知道）</h2><ul><li><p>在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象<br>在 Python 中可以使用以下两个方法验证：</p><pre><code>1. 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表
2. 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法
3. 提示 `__方法名__` 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性
</code></pre><p>| 序号 | 方法名 | 类型 | 作用 |<br>| —- | ———- | —- | ——————————————– |<br>| 01 | <code>__new__</code> | 方法 | <strong>创建对象</strong>时，会被 <strong>自动</strong> 调用 |<br>| 02 | <code>__init__</code> | 方法 | <strong>对象被初始化</strong>时，会被 <strong>自动</strong> 调用 |<br>| 03 | <code>__del__</code> | 方法 | <strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用 |<br>| 04 | <code>__str__</code> | 方法 | 返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用 |</p></li></ul><h2 id="02-定义简单的类（只包含方法）"><a href="#02-定义简单的类（只包含方法）" class="headerlink" title="02.定义简单的类（只包含方法）"></a>02.定义简单的类（只包含方法）</h2><blockquote><p>面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！</p></blockquote><h3 id="2-1-定义只包含方法的类"><a href="#2-1-定义只包含方法的类" class="headerlink" title="2.1 定义只包含方法的类"></a>2.1 定义只包含方法的类</h3><ul><li><p>在 Python 中要定义一个只包含方法的类，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法2<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>方法 的定义格式和之前学习过的函数 几乎一样</p></li><li>区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self</li></ul><blockquote><p>注意：类名 的 命名规则 要符合 大驼峰命名法</p></blockquote><h3 id="2-2-创建对象"><a href="#2-2-创建对象" class="headerlink" title="2.2 创建对象"></a>2.2 创建对象</h3><ul><li>当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象变量 = 类名()</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-第一个面向对象程序"><a href="#2-3-第一个面向对象程序" class="headerlink" title="2.3 第一个面向对象程序"></a>2.3 第一个面向对象程序</h3><p>需求</p><ul><li>小猫 爱 吃 鱼，小猫 要 喝 水<br>分析<ol><li>定义一个猫类 Cat</li><li>定义两个方法 eat 和 drink</li><li>按照需求 —— 不需要定义属性<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""这是一个猫类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"小猫爱吃鱼"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"小猫在喝水"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>引用概念的强调</p><blockquote><p>在面向对象开发中，引用的概念是同样适用的！</p></blockquote><ul><li>在 Python 中使用类 创建对象之后，tom 变量中 仍然记录的是 对象在内存中的地址</li><li>也就是 tom 变量 引用 了 新建的猫对象</li><li>使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）</li></ul><blockquote><p>提示：在计算机中，通常使用 十六进制 表示 内存地址</p><ul><li>十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样</li><li>十进制 和 十六进制 的数字之间可以来回转换</li></ul></blockquote><ul><li>%d 可以以 10 进制 输出数字</li><li>%x 可以以 16 进制 输出数字</li></ul><h2 id="03-方法中的-self-参数"><a href="#03-方法中的-self-参数" class="headerlink" title="03.方法中的 self 参数"></a>03.方法中的 self 参数</h2><h3 id="3-1-案例改造-——-给对象增加属性"><a href="#3-1-案例改造-——-给对象增加属性" class="headerlink" title="3.1 案例改造 —— 给对象增加属性"></a>3.1 案例改造 —— 给对象增加属性</h3><ul><li>在 Python 中，要 给对象设置属性，非常的容易，但是不推荐使用<ul><li>因为：对象属性的封装应该封装在类的内部</li></ul></li><li>只需要在 类的外部的代码 中直接通过 . 设置一个属性即可<blockquote><p>注意：这种方式虽然简单，但是不推荐使用！</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tom.name = <span class="string">"Tom"</span></span><br><span class="line">...</span><br><span class="line">lazy_cat.name = <span class="string">"大懒猫"</span></span><br></pre></td></tr></table></figure><h3 id="3-2-使用-self-在方法内部输出每一只猫的名字"><a href="#3-2-使用-self-在方法内部输出每一只猫的名字" class="headerlink" title="3.2 使用 self 在方法内部输出每一只猫的名字"></a>3.2 使用 self 在方法内部输出每一只猫的名字</h3><blockquote><p>由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用</p><ul><li>在类封装的方法内部，self 就表示 当前调用方法的对象自己</li><li>调用方法时，程序员不需要传递 self 参数</li><li>在方法内部<ul><li>可以通过 self. 访问对象的属性</li><li>也可以通过 self. 调用其他的对象方法</li></ul></li></ul></blockquote><ul><li><p>改造代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 爱吃鱼"</span> % self.name)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.name = <span class="string">"Tom"</span></span><br><span class="line">tom.eat()</span><br><span class="line"></span><br><span class="line">lazy_cat = Cat()</span><br><span class="line">lazy_cat.name = <span class="string">"大懒猫"</span></span><br><span class="line">lazy_cat.eat()</span><br></pre></td></tr></table></figure></li><li><p>在 类的外部，通过 变量名. 访问对象的 属性和方法(tom.name)</p></li><li>在 类封装的方法中，通过 self. 访问对象的 属性和方法(self.name)</li></ul><h2 id="04-初始化方法"><a href="#04-初始化方法" class="headerlink" title="04. 初始化方法"></a>04. 初始化方法</h2><h3 id="4-1-之前代码存在的问题-——-在类的外部给对象增加属性"><a href="#4-1-之前代码存在的问题-——-在类的外部给对象增加属性" class="headerlink" title="4.1 之前代码存在的问题 —— 在类的外部给对象增加属性"></a>4.1 之前代码存在的问题 —— 在类的外部给对象增加属性</h3><ul><li><p>将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br><span class="line">tom.name = <span class="string">"Tom"</span></span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure></li><li><p>程序执行报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">'Cat'</span> object has no attribute <span class="string">'name'</span></span><br><span class="line">属性错误：<span class="string">'Cat'</span> 对象没有 <span class="string">'name'</span> 属性</span><br></pre></td></tr></table></figure></li></ul><p>提示</p><ul><li>在日常开发中，不推荐在 类的外部 给对象增加属性<ul><li>如果在运行时，没有找到属性，程序会报错</li></ul></li><li>对象应该包含有哪些属性，应该 封装在类的内部</li></ul><h3 id="4-2-初始化方法"><a href="#4-2-初始化方法" class="headerlink" title="4.2 初始化方法"></a>4.2 初始化方法</h3><ul><li>当使用 类名() 创建对象时，会 自动 执行以下操作：<ol><li>为对象在内存中 分配空间 —— 创建对象</li><li>为对象的属性 设置初始值 —— 初始化方法(init)</li></ol></li><li>这个 初始化方法 就是 <strong>init</strong> 方法，<strong>init</strong> 是对象的内置方法<blockquote><p><strong>init</strong> 方法是 专门 用来定义一个类 具有哪些属性的方法！</p></blockquote></li></ul><p>在 Cat 中增加 <strong>init</strong> 方法，验证该方法在创建对象时会被自动调用<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="string">"""这是一个猫类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化方法"</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id="4-3-在初始化方法内部定义属性"><a href="#4-3-在初始化方法内部定义属性" class="headerlink" title="4.3 在初始化方法内部定义属性"></a>4.3 在初始化方法内部定义属性</h3><ul><li>在 <strong>init</strong> 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性</li><li>定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是一个初始化方法"</span>)</span><br><span class="line">        <span class="comment"># 定义用 Cat 类创建的猫对象都有一个 name 的属性</span></span><br><span class="line">        self.name = <span class="string">"Tom"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 爱吃鱼"</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类名()创建对象的时候，会自动调用初始化方法 __init__</span></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4-改造初始化方法-——-初始化的同时设置初始值"><a href="#4-4-改造初始化方法-——-初始化的同时设置初始值" class="headerlink" title="4.4 改造初始化方法 —— 初始化的同时设置初始值"></a>4.4 改造初始化方法 —— 初始化的同时设置初始值</h3><ul><li>在开发中，如果希望在 创建对象的同时，就设置对象的属性，可以对 <strong>init</strong> 方法进行 改造<ol><li>把希望设置的属性值，定义成 <strong>init</strong> 方法的参数</li><li>在方法内部使用 self.属性 = 形参 接收外部传递的参数</li><li>在创建对象时，使用 类名(属性1, 属性2…) 调用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化方法 %s"</span> % name)</span><br><span class="line">        self.name = name</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br><span class="line">...</span><br><span class="line">lazy_cat = Cat(<span class="string">"大懒猫"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="05-内置方法和属性"><a href="#05-内置方法和属性" class="headerlink" title="05. 内置方法和属性"></a>05. 内置方法和属性</h2><table><thead><tr><th>序号</th><th>方法名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td><code>__del__</code></td><td>方法</td><td><strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用</td></tr><tr><td>02</td><td><code>__str__</code></td><td>方法</td><td>返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用</td></tr></tbody></table><h3 id="5-1-del-方法（知道）"><a href="#5-1-del-方法（知道）" class="headerlink" title="5.1 del 方法（知道）"></a>5.1 <strong>del</strong> 方法（知道）</h3><ul><li>在 Python 中<ul><li>当使用 类名() 创建对象时，为对象 分配完空间后，自动 调用 <strong>init</strong> 方法</li><li>当一个 对象被从内存中销毁 前，会 自动 调用 <strong>del</strong> 方法</li></ul></li><li>应用场景<ul><li><strong>init</strong> 改造初始化方法，可以让创建对象更加灵活</li><li><strong>del</strong> 如果希望在对象被销毁前，再做一些事情，可以考虑一下 <strong>del</strong> 方法</li></ul></li><li>生命周期<ul><li>一个对象从调用 类名() 创建，生命周期开始</li><li>一个对象的 <strong>del</strong> 方法一旦被调用，生命周期结束</li><li>在对象的生命周期内，可以访问对象属性，或者让对象调用方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">        self.name = new_name</span><br><span class="line">        print(<span class="string">"%s 来了"</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 去了"</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tom 是一个全局变量</span></span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br><span class="line">print(tom.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># del 关键字可以删除一个对象</span></span><br><span class="line"><span class="keyword">del</span> tom</span><br><span class="line"></span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-str-方法"><a href="#5-2-str-方法" class="headerlink" title="5.2 str 方法"></a>5.2 <strong>str</strong> 方法</h3><ul><li>在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）</li><li>如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 <strong>str</strong> 这个内置方法了<blockquote><p>注意：<strong>str</strong> 方法必须返回一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">        self.name = new_name</span><br><span class="line">        print(<span class="string">"%s 来了"</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 去了"</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是小猫：%s"</span> % self.name</span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>返回结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tom 来了</span><br><span class="line">我是小猫：Tom</span><br><span class="line">Tom 去了</span><br></pre></td></tr></table></figure><p></p><p>解释：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__del__用于当对象的引用计数为0时自动调用。</span><br><span class="line">__del__一般出现在两个地方：1、手工使用del减少对象引用计数至0，被垃圾回收处理时调用。2、程序结束时调用。</span><br><span class="line">__del__一般用于需要声明在对象被删除前需要处理的资源回收操作</span><br></pre></td></tr></table></figure><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手工调用del 可以将对象引用计数减一，如果减到0，将会触发垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'调用对象的del方法，此方法将会回收此对象内存地址'</span>)</span><br><span class="line"></span><br><span class="line">stu = Student()  <span class="comment"># 调用对象的__del__方法回收此对象内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> stu</span><br><span class="line">print(<span class="string">'下面还有程序其他代码'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'调用对象的del方法，此方法将会回收此对象内存地址'</span>)</span><br><span class="line"></span><br><span class="line">stu = Student()  <span class="comment"># 程序直接结束，也会调用对象的__del__方法回收地址</span></span><br></pre></td></tr></table></figure><h1 id="面向对象封装案例"><a href="#面向对象封装案例" class="headerlink" title="面向对象封装案例"></a>面向对象封装案例</h1><h2 id="01-封装"><a href="#01-封装" class="headerlink" title="01. 封装"></a>01. 封装</h2><ol><li>封装 是面向对象编程的一大特点</li><li>面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中</li><li>外界 使用 类 创建 对象，然后 让对象调用方法</li><li>对象方法的细节 都被 封装 在 类的内部</li></ol><h2 id="02-小明爱跑步"><a href="#02-小明爱跑步" class="headerlink" title="02. 小明爱跑步"></a>02. 小明爱跑步</h2><p>需求</p><ol><li>小明 体重 75.0 公斤</li><li>小明每次 跑步 会减肥 0.5 公斤</li><li>小明每次 吃东西 体重增加 1 公斤</li></ol><table><thead><tr><th>Person</th></tr></thead><tbody><tr><td>name<br>weight</td></tr><tr><td><code>__init__(self,name,weight)</code>:<br><code>__str__(self)</code>:<br>run(self):<br>eat(self):</td></tr></tbody></table><blockquote><p>提示：在 对象的方法内部，是可以 直接访问对象的属性 的！</p></blockquote><p>代码实现：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">"""人类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字叫 %s 体重 %.2f 公斤"</span> % (self.name, self.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""跑步"""</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"%s 爱跑步，跑步锻炼身体"</span> % self.name)</span><br><span class="line">        self.weight -= <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""吃东西"""</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"%s 是吃货，吃完这顿再减肥"</span> % self.name)</span><br><span class="line">        self.weight += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">"小明"</span>, <span class="number">75</span>)</span><br><span class="line"></span><br><span class="line">xiaoming.run()</span><br><span class="line">xiaoming.eat()</span><br><span class="line">xiaoming.eat()</span><br><span class="line"></span><br><span class="line">print(xiaoming)</span><br></pre></td></tr></table></figure><p></p><h3 id="2-1-小明爱跑步扩展-——-小美也爱跑步"><a href="#2-1-小明爱跑步扩展-——-小美也爱跑步" class="headerlink" title="2.1 小明爱跑步扩展 —— 小美也爱跑步"></a>2.1 小明爱跑步扩展 —— 小美也爱跑步</h3><p>需求</p><ol><li>小明 和 小美 都爱跑步</li><li>小明 体重 75.0 公斤</li><li>小美 体重 45.0 公斤</li><li>每次 跑步 都会减少 0.5 公斤</li><li>每次 吃东西 都会增加 1 公斤</li></ol><table><thead><tr><th>Person</th></tr></thead><tbody><tr><td>name<br>weight</td></tr><tr><td><code>__init__(self,name,weight)</code>:<br><code>__str__(self)</code>:<br>run(self):<br>eat(self):</td></tr></tbody></table><p>提示</p><pre><code>1. 在 对象的方法内部，是可以 直接访问对象的属性 的
2. 同一个类 创建的 多个对象 之间，属性 互不干扰！
</code></pre><h2 id="03-摆放家具"><a href="#03-摆放家具" class="headerlink" title="03. 摆放家具"></a>03. 摆放家具</h2><p>需求</p><ol><li>房子(House) 有 户型、总面积 和 家具名称列表<ul><li>新房子没有任何的家具</li></ul></li><li>家具(HouseItem) 有 名字 和 占地面积，其中<ul><li>席梦思(bed) 占地 4 平米</li><li>衣柜(chest) 占地 2 平米</li><li>餐桌(table) 占地 1.5 平米</li></ul></li><li>将以上三件 家具 添加 到 房子 中</li><li>打印房子时，要求输出：户型、总面积、剩余面积、家具名称列表</li></ol><table><thead><tr><th>HouseItem</th></tr></thead><tbody><tr><td>name<br>area</td></tr><tr><td><code>__init__(self,name,area)</code>:<br><code>__str__(self)</code>:</td></tr></tbody></table><table><thead><tr><th>House</th></tr></thead><tbody><tr><td>house_type<br>area<br>free_area<br>item_list</td></tr><tr><td><code>__init__(self,house_type,area)</code>:<br><code>__str__(self)</code>:<br>add_item(self):</td></tr></tbody></table><p>剩余面积</p><ol><li>在创建房子对象时，定义一个 剩余面积的属性，初始值和总面积相等</li><li>当调用 add_item 方法，向房间 添加家具 时，让 剩余面积 -= 家具面积</li></ol><p>思考：应该先开发哪一个类？<br>答案 —— 家具类</p><ol><li>家具简单</li><li>房子要使用到家具，被使用的类，通常应该先开发</li></ol><h3 id="3-1-创建家具"><a href="#3-1-创建家具" class="headerlink" title="3.1 创建家具"></a>3.1 创建家具</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, area)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param name: 家具名称</span></span><br><span class="line"><span class="string">        :param area: 占地面积</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.area = area</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[%s] 占地面积 %.2f"</span> % (self.name, self.area)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建家具</span></span><br><span class="line">bed = HouseItem(<span class="string">"席梦思"</span>, <span class="number">4</span>)</span><br><span class="line">chest = HouseItem(<span class="string">"衣柜"</span>, <span class="number">2</span>)</span><br><span class="line">table = HouseItem(<span class="string">"餐桌"</span>, <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line">print(bed)</span><br><span class="line">print(chest)</span><br><span class="line">print(table)</span><br></pre></td></tr></table></figure><p>小结</p><ol><li>创建了一个 家具类，使用到 <strong>init</strong> 和 <strong>str</strong> 两个内置方法</li><li>使用 家具类 创建了 三个家具对象，并且 输出家具信息</li></ol><h3 id="3-2-创建房间"><a href="#3-2-创建房间" class="headerlink" title="3.2 创建房间"></a>3.2 创建房间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, house_type, area)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param house_type: 户型</span></span><br><span class="line"><span class="string">        :param area: 总面积</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.house_type = house_type</span><br><span class="line">        self.area = area</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩余面积默认和总面积一致</span></span><br><span class="line">        self.free_area = area</span><br><span class="line">        <span class="comment"># 默认没有任何的家具</span></span><br><span class="line">        self.item_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Python 能够自动的将一对括号内部的代码连接在一起</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"户型：%s\n总面积：%.2f[剩余：%.2f]\n家具：%s"</span></span><br><span class="line">                % (self.house_type, self.area,</span><br><span class="line">                   self.free_area, self.item_list))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"要添加 %s"</span> % item)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建房子对象</span></span><br><span class="line">my_home = House(<span class="string">"两室一厅"</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">my_home.add_item(bed)</span><br><span class="line">my_home.add_item(chest)</span><br><span class="line">my_home.add_item(table)</span><br><span class="line"></span><br><span class="line">print(my_home)</span><br></pre></td></tr></table></figure><p>小结</p><ol><li>创建了一个 房子类，使用到 <strong>init</strong> 和 <strong>str</strong> 两个内置方法</li><li>准备了一个 add_item 方法 准备添加家具</li><li>使用 房子类 创建了 一个房子对象</li><li>让 房子对象 调用了三次 add_item 方法，将 三件家具 以实参传递到 add_item 内部</li></ol><h3 id="3-3-添加家具"><a href="#3-3-添加家具" class="headerlink" title="3.3 添加家具"></a>3.3 添加家具</h3><p>需求</p><ul><li>1&gt; 判断 家具的面积 是否 超过剩余面积，如果超过，提示不能添加这件家具</li><li>2&gt; 将 家具的名称 追加到 家具名称列表 中</li><li>3&gt; 用 房子的剩余面积 - 家具面积</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, item)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"要添加 %s"</span> % item)</span><br><span class="line">    <span class="comment"># 1. 判断家具面积是否大于剩余面积</span></span><br><span class="line">    <span class="keyword">if</span> item.area &gt; self.free_area:</span><br><span class="line">        print(<span class="string">"%s 的面积太大，不能添加到房子中"</span> % item.name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 将家具的名称追加到名称列表中</span></span><br><span class="line">    self.item_list.append(item.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算剩余面积</span></span><br><span class="line">    self.free_area -= item.area</span><br></pre></td></tr></table></figure><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>主程序只负责创建 房子 对象和 家具 对象</li><li>让 房子 对象调用 add_item 方法 将家具添加到房子中</li><li>面积计算、剩余面积、家具列表 等处理都被 封装 到 房子类的内部</li></ul><h1 id="面向对象封装案例-II"><a href="#面向对象封装案例-II" class="headerlink" title="面向对象封装案例 II"></a>面向对象封装案例 II</h1><p>封装</p><ol><li>封装 是面向对象编程的一大特点</li><li>面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中</li><li>外界 使用 类 创建 对象，然后 让对象调用方法</li><li>细节 都被 封装 在 类的内部</li></ol><blockquote><p>一个对象的 属性 可以是 另外一个类创建的对象</p></blockquote><h2 id="01-士兵突击"><a href="#01-士兵突击" class="headerlink" title="01. 士兵突击"></a>01. 士兵突击</h2><p>需求</p><ol><li>许三多 有一把 AK47</li><li>可以 开火</li><li>够 发射 子弹</li><li>填 装填子弹 —— 增加子弹数量</li></ol><table><thead><tr><th>Soldier</th></tr></thead><tbody><tr><td>name<br>gun</td></tr><tr><td><code>__init__(self)</code>:<br>fire(self):</td></tr></tbody></table><table><thead><tr><th>Gun</th></tr></thead><tbody><tr><td>model<br>bullet_count</td></tr><tr><td><code>__init__(self,model)</code>:<br>add_bullet(self,count):<br>shoot(self):</td></tr></tbody></table><h3 id="1-1-开发枪类"><a href="#1-1-开发枪类" class="headerlink" title="1.1 开发枪类"></a>1.1 开发枪类</h3><p>shoot 方法需求</p><ul><li>1&gt; 判断是否有子弹，没有子弹无法射击</li><li>2&gt; 使用 print 提示射击，并且输出子弹数量<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        <span class="comment"># 枪的型号</span></span><br><span class="line">        self.model = model</span><br><span class="line">        <span class="comment"># 子弹数量</span></span><br><span class="line">        self.bullet_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_bullet</span><span class="params">(self, count)</span>:</span></span><br><span class="line">        self.bullet_count += count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoot</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 判断是否还有子弹</span></span><br><span class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"没有子弹了..."</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 发射一颗子弹</span></span><br><span class="line">        self.bullet_count -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"%s 发射子弹[%d]..."</span> % (self.model, self.bullet_count))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建枪对象</span></span><br><span class="line">ak47 = Gun(<span class="string">"ak47"</span>)</span><br><span class="line">ak47.add_bullet(<span class="number">50</span>)</span><br><span class="line">ak47.shoot()</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-开发士兵类"><a href="#1-2-开发士兵类" class="headerlink" title="1.2 开发士兵类"></a>1.2 开发士兵类</h3><blockquote><p>假设：每一个新兵 都 没有枪</p></blockquote><p>定义没有初始值的属性<br>在定义属性时，如果 不知道设置什么初始值，可以设置为 None</p><ul><li>None 关键字 表示 什么都没有</li><li>表示一个 空对象，没有方法和属性，是一个特殊的常量</li><li>可以将 None 赋值给任何一个变量</li></ul><p>fire 方法需求</p><ul><li>1&gt; 判断是否有枪，没有枪没法冲锋</li><li>2&gt; 喊一声口号</li><li>3&gt; 装填子弹</li><li>4&gt; 射击</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soldier</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 姓名</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 枪，士兵初始没有枪 None 关键字表示什么都没有</span></span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fire</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 判断士兵是否有枪</span></span><br><span class="line">        <span class="keyword">if</span> self.gun <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"[%s] 还没有枪..."</span> % self.name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 2. 高喊口号</span></span><br><span class="line">        print(<span class="string">"冲啊...[%s]"</span> % self.name)</span><br><span class="line">        <span class="comment"># 3. 让枪装填子弹</span></span><br><span class="line">        self.gun.add_bullet(<span class="number">50</span>)</span><br><span class="line">        <span class="comment"># 4. 让枪发射子弹</span></span><br><span class="line">        self.gun.shoot()</span><br></pre></td></tr></table></figure><p>小结</p><ol><li>创建了一个 士兵类，使用到 <strong>init</strong> 内置方法</li><li>在定义属性时，如果 不知道设置什么初始值，可以设置为 None</li><li>在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法</li></ol><h2 id="02-身份运算符"><a href="#02-身份运算符" class="headerlink" title="02. 身份运算符"></a>02. 身份运算符</h2><p>身份运算符用于 比较 两个对象的 内存地址 是否一致 —— 是否是对同一个对象的引用</p><ul><li>在 Python 中针对 None 比较时，建议使用 is 判断</li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用同一个对象</td><td>x is y，类似 id(x) == id(y)</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用不同对象</td><td>x is not y，类似 id(a) != id(b)</td></tr></tbody></table><p>is 与 == 区别：</p><ul><li>is 用于判断 两个变量 引用对象是否为同一个</li><li>== 用于判断 引用变量的值 是否相等<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b == a</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li></ul><h1 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h1><h2 id="01-应用场景及定义方式"><a href="#01-应用场景及定义方式" class="headerlink" title="01. 应用场景及定义方式"></a>01. 应用场景及定义方式</h2><p>应用场景</p><ul><li>在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到</li><li>私有属性 就是 对象 不希望公开的 属性</li><li>私有方法 就是 对象 不希望公开的 方法</li></ul><p>定义方式</p><ul><li>在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 不要问女生的年龄</span></span><br><span class="line">        self.__age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我的年龄是 %d"</span> % self.__age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaofang = Women(<span class="string">"小芳"</span>)</span><br><span class="line"><span class="comment"># 私有属性，外部不能直接访问</span></span><br><span class="line"><span class="comment"># print(xiaofang.__age)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有方法，外部不能直接调用</span></span><br><span class="line"><span class="comment"># xiaofang.__secret()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="02-伪私有属性和私有方法（知识点）"><a href="#02-伪私有属性和私有方法（知识点）" class="headerlink" title="02. 伪私有属性和私有方法（知识点）"></a>02. 伪私有属性和私有方法（知识点）</h2><blockquote><p>提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法</p></blockquote><p>Python 中，并没有 真正意义 的 私有</p><ul><li>在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到</li><li>处理方式：在 名称 前面加上 _类名 =&gt; _类名__名称<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 私有属性，外部不能直接访问到</span></span><br><span class="line">print(xiaofang._Women__age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有方法，外部不能直接调用</span></span><br><span class="line">xiaofang._Women__secret()</span><br></pre></td></tr></table></figure></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>面向对象三大特性</p><ol><li>封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中</li><li>继承 实现代码的重用，相同的代码不需要重复的编写</li><li>多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度</li></ol><h2 id="01-单继承"><a href="#01-单继承" class="headerlink" title="01. 单继承"></a>01. 单继承</h2><h3 id="1-1-继承的概念、语法和特点"><a href="#1-1-继承的概念、语法和特点" class="headerlink" title="1.1 继承的概念、语法和特点"></a>1.1 继承的概念、语法和特点</h3><p>继承的概念：子类 拥有 父类 的所有 方法 和 属性</p><p>1) 继承的语法<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类名(父类名):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p></p><ul><li>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</li><li>子类 中应该根据 职责，封装 子类特有的 属性和方法</li></ul><p>2) 专业术语</p><ul><li>Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承</li><li>Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生</li></ul><p>3) 继承的传递性</p><ul><li>C 类从 B 类继承，B 类又从 A 类继承</li><li>那么 C 类就具有 B 类和 A 类的所有属性和方法</li></ul><p>子类 拥有 父类 以及 父类的父类 中封装的所有 属性 和 方法</p><h3 id="1-2-方法的重写"><a href="#1-2-方法的重写" class="headerlink" title="1.2 方法的重写"></a>1.2 方法的重写</h3><ul><li>子类 拥有 父类 的所有 方法 和 属性</li><li>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</li></ul><p>应用场景</p><ul><li>当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)</li></ul><p>重写 父类方法有两种情况：</p><ol><li>覆盖 父类的方法</li><li>对父类方法进行 扩展</li></ol><p>1) 覆盖父类的方法</p><ul><li>如果在开发中，父类的方法实现 和 子类的方法实现，完全不同</li><li>就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现<blockquote><p>具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现</p></blockquote></li></ul><p>重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法</p><p>2) 对父类方法进行 扩展</p><ul><li>如果在开发中，子类的方法实现 中 包含 父类的方法实现<ul><li>父类原本封装的方法实现 是 子类方法的一部分</li></ul></li><li>就可以使用 扩展 的方式<ol><li>在子类中 重写 父类的方法</li><li>在需要的位置使用 super().父类方法 来调用父类方法的执行</li><li>代码其他的位置针对子类的需求，编写 子类特有的代码实现</li></ol></li></ul><p>关于 super</p><ul><li>在 Python 中 super 是一个 特殊的类</li><li>super() 就是使用 super 类创建出来的对象</li><li>最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现</li></ul><p>调用父类方法的另外一种方式（知道）</p><blockquote><p>在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure><p></p></blockquote><ul><li>这种方式，目前在 Python 3.x 还支持这种方式</li><li>这种方法 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改</li></ul><p>提示</p><ul><li>在开发时，父类名 和 super() 两种方式不要混用</li><li>如果使用 当前子类名 调用方法，会形成递归调用，出现死循环</li></ul><h3 id="1-3-父类的-私有属性-和-私有方法"><a href="#1-3-父类的-私有属性-和-私有方法" class="headerlink" title="1.3 父类的 私有属性 和 私有方法"></a>1.3 父类的 私有属性 和 私有方法</h3><ol><li>子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法</li><li>子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法</li></ol><blockquote><ul><li>私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类 都不能直接访问</li><li>私有属性、方法 通常用于做一些内部的事情</li></ul></blockquote><h2 id="02-多继承"><a href="#02-多继承" class="headerlink" title="02. 多继承"></a>02. 多继承</h2><p>概念</p><ul><li>子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法</li><li>例如：孩子 会继承自己 父亲 和 母亲 的 特性<br>语法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 子类名(父类名1, 父类名2...)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-多继承的使用注意事项"><a href="#2-1-多继承的使用注意事项" class="headerlink" title="2.1 多继承的使用注意事项"></a>2.1 多继承的使用注意事项</h3><p>如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？</p><blockquote><p>开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承</p></blockquote><p>Python 中的 MRO —— 方法搜索顺序（知道）</p><ul><li>Python 中针对 类 提供了一个 内置属性 <strong>mro</strong> 可以查看 方法 搜索顺序</li><li><p>MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(类名.__mro__)</span><br></pre></td></tr></table></figure></li><li><p>在搜索方法时，是按照 <strong>mro</strong> 的输出结果 从左至右 的顺序查找的</p></li><li>如果在当前类中 找到方法，就直接执行，不再搜索</li><li>如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索</li><li>如果找到最后一个类，还没有找到方法，程序报错</li></ul><h2 id="2-2-新式类与旧式（经典）类"><a href="#2-2-新式类与旧式（经典）类" class="headerlink" title="2.2 新式类与旧式（经典）类"></a>2.2 新式类与旧式（经典）类</h2><blockquote><p>object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看</p></blockquote><ul><li>新式类：以 object 为基类的类，推荐使用</li><li>经典类：不以 object 为基类的类，不推荐使用</li><li>在 Python 3.x 中定义类时，如果没有指定父类，会 默认使用 object 作为该类的 基类 —— Python 3.x 中定义的类都是 新式类</li><li>在 Python 2.x 中定义类时，如果没有指定父类，则不会以 object 作为 基类<blockquote><p>新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序</p></blockquote></li></ul><p>为了保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行！<br>今后在定义类时，如果没有父类，建议统一继承自 object<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>面向对象三大特性</p><ol><li>封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中<ul><li>定义类的准则</li></ul></li><li>继承 实现代码的重用，相同的代码不需要重复的编写<ul><li>设计类的技巧</li><li>子类针对自己特有的需求，编写特定的代码</li></ul></li><li>多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果<ul><li>多态 可以 增加代码的灵活度</li><li>以 继承 和 重写父类方法 为前提</li><li>是调用方法的技巧，不会影响到类的内部设计</li></ul></li></ol><h2 id="多态案例演练"><a href="#多态案例演练" class="headerlink" title="多态案例演练"></a>多态案例演练</h2><p>需求</p><ol><li>在 Dog 类中封装方法 game<ul><li>普通狗只是简单的玩耍</li></ul></li><li>定义 XiaoTianDog 继承自 Dog，并且重写 game 方法<ul><li>哮天犬需要在天上玩耍</li></ul></li><li>定义 Person 类，并且封装一个 和狗玩 的方法<ul><li>在方法内部，直接让 狗对象 调用 game 方法</li></ul></li></ol><p>案例小结</p><ul><li>Person 类中只需要让 狗对象 调用 game 方法，而不关心具体是 什么狗<ul><li>game 方法是在 Dog 父类中定义的</li></ul></li><li>在程序执行时，传入不同的 狗对象 实参，就会产生不同的执行效果<blockquote><p>多态 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 蹦蹦跳跳的玩耍..."</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianDog</span><span class="params">(Dog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 飞到天上去玩耍..."</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game_with_dog</span><span class="params">(self, dog)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 和 %s 快乐的玩耍..."</span> % (self.name, dog.name))</span><br><span class="line">        <span class="comment"># 让狗玩耍</span></span><br><span class="line">        dog.game()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个狗对象</span></span><br><span class="line"><span class="comment"># wangcai = Dog("旺财")</span></span><br><span class="line">wangcai = XiaoTianDog(<span class="string">"飞天旺财"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建一个小明对象</span></span><br><span class="line">xiaoming = Person(<span class="string">"小明"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 让小明调用和狗玩的方法</span></span><br><span class="line">xiaoming.game_with_dog(wangcai)</span><br></pre></td></tr></table></figure><h1 id="类属性和类方法"><a href="#类属性和类方法" class="headerlink" title="类属性和类方法"></a>类属性和类方法</h1><h2 id="01-类的结构"><a href="#01-类的结构" class="headerlink" title="01. 类的结构"></a>01. 类的结构</h2><h3 id="1-1-术语-——-实例"><a href="#1-1-术语-——-实例" class="headerlink" title="1.1 术语 —— 实例"></a>1.1 术语 —— 实例</h3><ol><li>使用面相对象开发，第 1 步 是设计 类</li><li>使用 类名() 创建对象，创建对象 的动作有两步：</li></ol><ul><li>1) 在内存中为对象 分配空间</li><li>2) 调用初始化方法 <strong>init</strong> 为 对象初始化</li></ul><ol start="3"><li>对象创建后，内存 中就有了一个对象的 实实在在 的存在 —— 实例</li></ol><p>因此，通常也会把：</p><ol><li>创建出来的 对象 叫做 类 的 实例</li><li>创建对象的 动作 叫做 实例化</li><li>对象的属性 叫做 实例属性</li><li>对象调用的方法 叫做 实例方法</li></ol><p>在程序执行时：</p><ol><li>对象各自拥有自己的 实例属性</li><li>调用对象方法，可以通过 self.<ul><li>访问自己的属性</li><li>调用自己的方法</li></ul></li></ol><p>结论</p><ul><li>每一个对象 都有自己 独立的内存空间，保存各自不同的属性</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部</li></ul><h3 id="1-2-类是一个特殊的对象"><a href="#1-2-类是一个特殊的对象" class="headerlink" title="1.2 类是一个特殊的对象"></a>1.2 类是一个特殊的对象</h3><blockquote><p>Python 中 一切皆对象：</p><ul><li>class AAA: 定义的类属于 类对象</li><li>obj1 = AAA() 属于 实例对象</li></ul></blockquote><ul><li>在程序运行时，类 同样 会被加载到内存</li><li>在 Python 中，类 是一个特殊的对象 —— 类对象</li><li>在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例</li><li><p>除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法</p><ol><li>类属性</li><li>类方法</li></ol></li><li><p>通过 类名. 的方式可以 访问类的属性 或者 调用类的方法</p></li></ul><h2 id="02-类属性和实例属性"><a href="#02-类属性和实例属性" class="headerlink" title="02. 类属性和实例属性"></a>02. 类属性和实例属性</h2><h3 id="2-1-概念和使用"><a href="#2-1-概念和使用" class="headerlink" title="2.1 概念和使用"></a>2.1 概念和使用</h3><ul><li>类属性 就是给 类对象 中定义的 属性</li><li>通常用来记录 与这个类相关 的特征</li><li>类属性 不会用于记录 具体对象的特征</li></ul><p>示例需求</p><ul><li>定义一个 工具类</li><li>每件工具都有自己的 name</li><li>需求 —— 知道使用这个类，创建了多少个工具对象？<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 使用赋值语句，定义类属性，记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 针对类属性做一个计数+1</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">"斧头"</span>)</span><br><span class="line">tool2 = Tool(<span class="string">"榔头"</span>)</span><br><span class="line">tool3 = Tool(<span class="string">"铁锹"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 知道使用 Tool 类到底创建了多少个对象?</span></span><br><span class="line">print(<span class="string">"现在创建了 %d 个工具"</span> % Tool.count)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-属性的获取机制（科普）"><a href="#2-2-属性的获取机制（科普）" class="headerlink" title="2.2 属性的获取机制（科普）"></a>2.2 属性的获取机制（科普）</h3><ul><li>在 Python 中 属性的获取 存在一个 向上查找机制</li><li>因此，要访问类属性有两种方式：<ol><li>类名.类属性</li><li>对象.类属性 （不推荐）<br>注意</li></ol></li><li>如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值</li></ul><h2 id="03-类方法和静态方法"><a href="#03-类方法和静态方法" class="headerlink" title="03. 类方法和静态方法"></a>03. 类方法和静态方法</h2><h3 id="3-1-类方法"><a href="#3-1-类方法" class="headerlink" title="3.1 类方法"></a>3.1 类方法</h3><ul><li>类属性 就是针对 类对象 定义的属性<ul><li>使用 赋值语句 在 class 关键字下方可以定义 类属性</li><li>类属性 用于记录 与这个类相关 的特征</li></ul></li><li><p>类方法 就是针对 类对象 定义的方法</p><ul><li>在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法<br>语法如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法</p></li><li>类方法的 第一个参数 应该是 cls<ul><li>由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用</li><li>这个参数和 实例方法 的第一个参数是 self 类似</li><li>提示 使用其他名称也可以，不过习惯使用 cls</li></ul></li><li>通过 类名. 调用 类方法，调用方法时，不需要传递 cls 参数</li><li>在方法内部<ul><li>可以通过 cls. 访问类的属性</li><li>也可以通过 cls. 调用其他的类方法</li></ul></li></ul><p>示例需求</p><ul><li>定义一个 工具类</li><li>每件工具都有自己的 name</li><li>需求 —— 在 类 封装一个 show_tool_count 的类方法，输出使用当前这个类，创建的对象个数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_tool_count</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="string">"""显示工具对象的总数"""</span></span><br><span class="line">    print(<span class="string">"工具对象的总数 %d"</span> % cls.count)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在类方法内部，可以直接使用 cls 访问 类属性 或者 调用类方法</p></blockquote><h3 id="3-2-静态方法"><a href="#3-2-静态方法" class="headerlink" title="3.2 静态方法"></a>3.2 静态方法</h3><ul><li>在开发时，如果需要在 类 中封装一个方法，这个方法：<ul><li>既 不需要 访问 实例属性 或者调用 实例方法</li><li>也 不需要 访问 类属性 或者调用 类方法</li></ul></li><li><p>这个时候，可以把这个方法封装成一个 静态方法<br>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法</p></li><li>通过 类名. 调用 静态方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="comment"># 狗对象计数</span></span><br><span class="line">    dog_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span> </span><br><span class="line">        <span class="comment"># 不需要访问实例属性也不需要访问类属性的方法</span></span><br><span class="line">        print(<span class="string">"狗在跑..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-方法综合案例"><a href="#3-3-方法综合案例" class="headerlink" title="3.3 方法综合案例"></a>3.3 方法综合案例</h3><p>需求</p><ol><li>设计一个 Game 类</li><li>属性：<ul><li>定义一个 类属性 top_score 记录游戏的 历史最高分</li><li>定义一个 实例属性 player_name 记录 当前游戏的玩家姓名</li></ul></li><li>方法：<ul><li>静态方法 show_help 显示游戏帮助信息</li><li>类方法 show_top_score 显示历史最高分</li><li>实例方法 start_game 开始当前玩家的游戏</li></ul></li><li>主程序步骤<ul><li>1) 查看帮助信息</li><li>2) 查看历史最高分</li><li>3) 创建游戏对象，开始游戏</li></ul></li></ol><p>案例小结</p><ol><li>实例方法 —— 方法内部需要访问 实例属性<ul><li>实例方法 内部可以使用 类名. 访问类属性</li></ul></li><li>类方法 —— 方法内部 只 需要访问 类属性</li><li>静态方法 —— 方法内部，不需要访问 实例属性 和 类属性<br>提问<br>如果方法内部 即需要访问 实例属性，又需要访问 类属性，应该定义成什么方法？<br>答案</li></ol><ul><li>应该定义 实例方法</li><li>因为，类只有一个，在 实例方法 内部可以使用 类名. 访问类属性<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 游戏最高分，类属性</span></span><br><span class="line">    top_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_help</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"帮助信息：让僵尸走进房间"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_top_score</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"游戏最高分是 %d"</span> % cls.top_score)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, player_name)</span>:</span></span><br><span class="line">        self.player_name = player_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"[%s] 开始游戏..."</span> % self.player_name)  </span><br><span class="line">        <span class="comment"># 使用类名.修改历史最高分</span></span><br><span class="line">        Game.top_score = <span class="number">999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查看游戏帮助</span></span><br><span class="line">Game.show_help()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看游戏最高分</span></span><br><span class="line">Game.show_top_score()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建游戏对象，开始游戏</span></span><br><span class="line">game = Game(<span class="string">"小明"</span>)</span><br><span class="line"></span><br><span class="line">game.start_game()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 游戏结束，查看游戏最高分</span></span><br><span class="line">Game.show_top_score()</span><br></pre></td></tr></table></figure></li></ul><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><h2 id="01-单例设计模式"><a href="#01-单例设计模式" class="headerlink" title="01. 单例设计模式"></a>01. 单例设计模式</h2><ul><li>设计模式<ul><li>设计模式 是 前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对 某一特定问题 的成熟的解决方案</li><li>使用 设计模式 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li></ul></li><li>单例设计模式<ul><li>目的 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例</li><li>每一次执行 类名() 返回的对象，内存地址是相同的<br>单例设计模式的应用场景</li></ul></li><li>音乐播放 对象</li><li>回收站 对象</li><li>打印机 对象</li><li>……</li></ul><h2 id="02-new-方法"><a href="#02-new-方法" class="headerlink" title="02. new 方法"></a>02. <strong>new</strong> 方法</h2><ul><li>使用 类名() 创建对象时，Python 的解释器 首先 会 调用 <strong>new</strong> 方法为对象 分配空间</li><li><code>__new__</code> 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：<ul><li>1) 在内存中为对象 分配空间</li><li>2)返回 对象的引用</li></ul></li><li><p>Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 <strong>init</strong> 方法</p><blockquote><p>重写 <strong>new</strong> 方法 的代码非常固定！</p></blockquote></li><li><p>重写 <strong>new</strong> 方法 一定要 return super().<strong>new</strong>(cls)</p></li><li>否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法</li><li>注意：<strong>new</strong> 是一个静态方法，在调用时需要 主动传递 cls 参数<br>示例代码:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 如果不返回任何结果，</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化音乐播放对象"</span>)</span><br><span class="line"></span><br><span class="line">player = MusicPlayer()</span><br><span class="line">print(player)</span><br></pre></td></tr></table></figure></li></ul><h2 id="03-Python-中的单例"><a href="#03-Python-中的单例" class="headerlink" title="03. Python 中的单例"></a>03. Python 中的单例</h2><ul><li>单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例<ol><li>定义一个 类属性，初始值是 None，用于记录 单例对象的引用</li><li>重写 <strong>new</strong> 方法</li><li>如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果</li><li>返回 类属性 中记录的 对象引用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 定义类属性记录单例对象引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否已经被赋值</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 返回类属性的单例引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="3-1只执行一次初始化工作"><a href="#3-1只执行一次初始化工作" class="headerlink" title="3.1只执行一次初始化工作"></a>3.1只执行一次初始化工作</h3><ul><li>在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：<ul><li><strong>new</strong> 分配空间</li><li><strong>init</strong> 对象初始化</li></ul></li><li>在上一小节对 <strong>new</strong> 方法改造之后，每次都会得到 第一次被创建对象的引用</li><li>但是：初始化方法还会被再次调用</li></ul><p>需求</p><ul><li>让 初始化动作 只被 执行一次</li></ul><p>解决办法</p><ul><li>定义一个类属性 init_flag 标记是否 执行过初始化动作，初始值为 False</li><li>在 <strong>init</strong> 方法中，判断 init_flag，如果为 False 就执行初始化动作</li><li>然后将 init_flag 设置为 True</li><li>这样，再次 自动 调用 <strong>init</strong> 方法时，初始化动作就不会被再次执行 了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 记录是否执行过初始化动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> MusicPlayer.init_flag:</span><br><span class="line">            print(<span class="string">"初始化音乐播放器"</span>)</span><br><span class="line"></span><br><span class="line">            MusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个对象</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line">print(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line">print(player2)</span><br></pre></td></tr></table></figure></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>如果觉得我的文章对您有用,请随意打赏.您的支持将鼓励我继续创作!</div><br><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/img/wechat.jpg" alt="永夜初晗凝碧天 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/img/alipay.jpg" alt="永夜初晗凝碧天 支付宝"><p>支付宝</p></div></div></div></div><div><div class="post-copyright"><li class="post-copyright-title"><strong>本文标题：</strong> python_面向对象</li><li class="post-copyright-author"><strong>文章作者：</strong> 永夜初晗凝碧天</li><li class="post-copyright-author"><strong>发布时间：</strong> 2019年12月31日 - 12:12:27</li><li class="post-copyright-author"><strong>更新时间：</strong> 2019年12月31日 - 12:12:27</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="/2019/12/31/python_面向对象/" title="python_面向对象">https://yongnights.github.io/2019/12/31/python_面向对象/</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://yongnights.github.io/2019/12/31/python_面向对象/" aria-label="复制成功！"></i></span></li><li class="post-copyright-license"><strong>版权声明： </strong><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</li></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/12/31/python_闭包和装饰器/" rel="next" title="python_闭包和装饰器"><i class="fa fa-chevron-left"></i> python_闭包和装饰器</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/12/31/scrapy学习/" rel="prev" title="scrapy学习">scrapy学习 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a> <a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/img/avatar.png" alt="永夜初晗凝碧天"><p class="site-author-name" itemprop="name">永夜初晗凝碧天</p><p class="site-description motion-element" itemprop="description">Linux,Python,MySQL,ELK Stack,K8S,Docker</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">141</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">55</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="tencent://message/?Menu=yes&uin=1103324414" target="_blank" title="QQ"><i class="fa fa-fw fa-qq"></i>QQ</a> </span><span class="links-of-author-item"><a href="mailto:sandu12345@msn.cn" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1333220817&auto=0&height=66"></iframe><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/sanduzxcvbnm/" title="博客园" target="_blank">博客园</a></li><li class="links-of-blogroll-item"><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></li></ul></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li><a href="/2020/04/28/Elasticsearch IK 分词器 /" title="Elasticsearch IK 分词器" target="_blank">Elasticsearch IK 分词器</a></li><li><a href="/2020/04/28/为Elasticsearch启动https访问 /" title="为Elasticsearch启动https访问" target="_blank">为Elasticsearch启动https访问</a></li><li><a href="/2020/04/26/FastAPI框架入门 基本使用, 模版渲染, form表单数据交互, 上传文件, 静态文件配置/" title="FastAPI框架入门 基本使用, 模版渲染, form表单数据交互, 上传文件, 静态文件配置" target="_blank">FastAPI框架入门 基本使用, 模版渲染, form表单数据交互, 上传文件, 静态文件配置</a></li><li><a href="/2020/04/17/Elasticsearch：使用_update_by_query更新文档/" title="Elasticsearch：使用_update_by_query更新文档" target="_blank">Elasticsearch：使用_update_by_query更新文档</a></li><li><a href="/2020/04/15/Solutions：安全的APM服务器访问/" title="Solutions：安全的APM服务器访问" target="_blank">Solutions：安全的APM服务器访问</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象-OOP-基本概念"><span class="nav-text">面向对象(OOP)基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-面向对象基本概念"><span class="nav-text">01. 面向对象基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-过程和函数（科普）"><span class="nav-text">1.1 过程和函数（科普）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-面相过程-和-面相对象-基本概念"><span class="nav-text">1.2 面相过程 和 面相对象 基本概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类和对象"><span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-类和对象的概念"><span class="nav-text">01. 类和对象的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-类"><span class="nav-text">1.1 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-类和对象的关系"><span class="nav-text">02. 类和对象的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-类的设计"><span class="nav-text">03. 类的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-类名的确定"><span class="nav-text">3.1 类名的确定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面相对象基础语法"><span class="nav-text">面相对象基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-dir-内置函数（知道）"><span class="nav-text">01. dir 内置函数（知道）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-定义简单的类（只包含方法）"><span class="nav-text">02.定义简单的类（只包含方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-定义只包含方法的类"><span class="nav-text">2.1 定义只包含方法的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-创建对象"><span class="nav-text">2.2 创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-第一个面向对象程序"><span class="nav-text">2.3 第一个面向对象程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-方法中的-self-参数"><span class="nav-text">03.方法中的 self 参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-案例改造-——-给对象增加属性"><span class="nav-text">3.1 案例改造 —— 给对象增加属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-使用-self-在方法内部输出每一只猫的名字"><span class="nav-text">3.2 使用 self 在方法内部输出每一只猫的名字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-初始化方法"><span class="nav-text">04. 初始化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-之前代码存在的问题-——-在类的外部给对象增加属性"><span class="nav-text">4.1 之前代码存在的问题 —— 在类的外部给对象增加属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-初始化方法"><span class="nav-text">4.2 初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-在初始化方法内部定义属性"><span class="nav-text">4.3 在初始化方法内部定义属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-改造初始化方法-——-初始化的同时设置初始值"><span class="nav-text">4.4 改造初始化方法 —— 初始化的同时设置初始值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-内置方法和属性"><span class="nav-text">05. 内置方法和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-del-方法（知道）"><span class="nav-text">5.1 del 方法（知道）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-str-方法"><span class="nav-text">5.2 str 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象封装案例"><span class="nav-text">面向对象封装案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-封装"><span class="nav-text">01. 封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-小明爱跑步"><span class="nav-text">02. 小明爱跑步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-小明爱跑步扩展-——-小美也爱跑步"><span class="nav-text">2.1 小明爱跑步扩展 —— 小美也爱跑步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-摆放家具"><span class="nav-text">03. 摆放家具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-创建家具"><span class="nav-text">3.1 创建家具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-创建房间"><span class="nav-text">3.2 创建房间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-添加家具"><span class="nav-text">3.3 添加家具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-小结"><span class="nav-text">3.4 小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象封装案例-II"><span class="nav-text">面向对象封装案例 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-士兵突击"><span class="nav-text">01. 士兵突击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-开发枪类"><span class="nav-text">1.1 开发枪类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-开发士兵类"><span class="nav-text">1.2 开发士兵类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-身份运算符"><span class="nav-text">02. 身份运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#私有属性和私有方法"><span class="nav-text">私有属性和私有方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-应用场景及定义方式"><span class="nav-text">01. 应用场景及定义方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-伪私有属性和私有方法（知识点）"><span class="nav-text">02. 伪私有属性和私有方法（知识点）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-单继承"><span class="nav-text">01. 单继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-继承的概念、语法和特点"><span class="nav-text">1.1 继承的概念、语法和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-方法的重写"><span class="nav-text">1.2 方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-父类的-私有属性-和-私有方法"><span class="nav-text">1.3 父类的 私有属性 和 私有方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-多继承"><span class="nav-text">02. 多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-多继承的使用注意事项"><span class="nav-text">2.1 多继承的使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-新式类与旧式（经典）类"><span class="nav-text">2.2 新式类与旧式（经典）类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态"><span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多态案例演练"><span class="nav-text">多态案例演练</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类属性和类方法"><span class="nav-text">类属性和类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-类的结构"><span class="nav-text">01. 类的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-术语-——-实例"><span class="nav-text">1.1 术语 —— 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-类是一个特殊的对象"><span class="nav-text">1.2 类是一个特殊的对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-类属性和实例属性"><span class="nav-text">02. 类属性和实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-概念和使用"><span class="nav-text">2.1 概念和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-属性的获取机制（科普）"><span class="nav-text">2.2 属性的获取机制（科普）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-类方法和静态方法"><span class="nav-text">03. 类方法和静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-类方法"><span class="nav-text">3.1 类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-静态方法"><span class="nav-text">3.2 静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-方法综合案例"><span class="nav-text">3.3 方法综合案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例"><span class="nav-text">单例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-单例设计模式"><span class="nav-text">01. 单例设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-new-方法"><span class="nav-text">02. new 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-Python-中的单例"><span class="nav-text">03. Python 中的单例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1只执行一次初始化工作"><span class="nav-text">3.1只执行一次初始化工作</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-star"></i> </span><span class="author" itemprop="copyrightHolder">永夜初晗凝碧天</span><br></div><div><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">博客全站字数统计 </span><span title="博客全站字数统计">: 412.1k 字</span> <span class="post-meta-divider">||</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("03/01/2019 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="博客已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分钟 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script></div><div class="busuanzi-count"><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i> 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 </span><span class="post-meta-divider">||</span> <span id="busuanzi_container_site_uv"><i class="fa fa-user"></i> 本站访客数<span id="busuanzi_value_site_uv"></span>人次 </span><span class="post-meta-divider">||</span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> 本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div id="nowDate"><script type="text/javascript">window.onload=function(){function e(){var e=new Date,r=e.getFullYear(),u=e.getMonth()+1,a=e.getDate(),g=e.getDay(),i=e.getHours(),c=e.getMinutes(),d=e.getSeconds(),l="当前时间是："+r+"年"+u+"月"+a+"日 "+t(g)+" "+n(i)+":"+n(c)+":"+n(d);o.innerHTML=l}function t(e){return 0==e?"星期日":1==e?"星期一":2==e?"星期二":3==e?"星期三":4==e?"星期四":5==e?"星期五":"星期六"}function n(e){return e<10?"0"+e:e}var o=document.getElementById("nowDate");e(),setInterval(e,1e3)}</script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone",new needShareButton("#needsharebutton-float",flOptions)</script><script type="text/javascript" src="/js/src/love.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/src/fireworks.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by neat -->